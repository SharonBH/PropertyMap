/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * SBH.HomeMap.WebApi
 * .NET 9 HomeMAP API
 * OpenAPI spec version: 1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './customAxiosClient';
import type { ErrorType , BodyType } from './customAxiosClient';
export interface ActivateTenantResponse {
  /** @nullable */
  status?: string | null;
}

export interface AgencyResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  telephone?: string | null;
  /** @nullable */
  address?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  logoURL?: string | null;
  /** @nullable */
  primaryColor?: string | null;
  /** @nullable */
  additionalInfo?: string | null;
}

export interface AgencyResponsePagedList {
  /** @nullable */
  items?: AgencyResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface AssignUserRoleCommand {
  /** @nullable */
  userRoles?: UserRoleDetail[] | null;
}

export interface AuditTrail {
  id?: string;
  userId?: string;
  /** @nullable */
  operation?: string | null;
  /** @nullable */
  entity?: string | null;
  dateTime?: string;
  /** @nullable */
  previousValues?: string | null;
  /** @nullable */
  newValues?: string | null;
  /** @nullable */
  modifiedProperties?: string | null;
  /** @nullable */
  primaryKey?: string | null;
}

export interface BrandResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface BrandResponsePagedList {
  /** @nullable */
  items?: BrandResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface ChangePasswordCommand {
  /** @nullable */
  password?: string | null;
  /** @nullable */
  newPassword?: string | null;
  /** @nullable */
  confirmNewPassword?: string | null;
}

export interface CityResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  regionId?: string;
}

export interface CityResponsePagedList {
  /** @nullable */
  items?: CityResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface CreateAgencyCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  telephone?: string | null;
  /** @nullable */
  address?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  logoURL?: string | null;
  /** @nullable */
  primaryColor?: string | null;
  /** @nullable */
  additionalInfo?: string | null;
}

export interface CreateAgencyResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  telephone?: string | null;
  /** @nullable */
  adress?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  logoURL?: string | null;
  /** @nullable */
  primaryColor?: string | null;
  /** @nullable */
  additionalInfo?: string | null;
}

export interface CreateBrandCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  logoUrl?: string | null;
}

export interface CreateBrandResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreateCityCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  regionId?: string;
}

export interface CreateCityResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreateNeighborhoodCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  cityId?: string;
  /** @nullable */
  sphereImgURL?: string | null;
  /** @nullable */
  iconURL?: string | null;
  score?: number;
}

export interface CreateNeighborhoodResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreateOrUpdateRoleCommand {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface CreateProductCommand {
  /** @nullable */
  name?: string | null;
  price?: number;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  brandId?: string | null;
}

export interface CreateProductResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreatePropertyCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  neighborhoodId?: string;
  /** @nullable */
  address?: string | null;
  askingPrice?: number;
  size?: number;
  rooms?: number;
  bathrooms?: number;
  propertyTypeId?: string;
  agencyId?: string;
  listedDate?: string;
  /** @nullable */
  featureList?: string | null;
}

export interface CreatePropertyResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreatePropertyTypeCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface CreatePropertyTypeResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreateRegionCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface CreateRegionResponse {
  /** @nullable */
  id?: string | null;
}

export interface CreateReviewCommand {
  /** @nullable */
  reviewer?: string | null;
  /** @nullable */
  content?: string | null;
  score?: number;
  reviewDate?: string;
  agencyId?: string;
}

export interface CreateReviewResponse {
  id?: string;
}

export interface CreateTenantCommand {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  connectionString?: string | null;
  /** @nullable */
  adminEmail?: string | null;
  /** @nullable */
  issuer?: string | null;
}

export interface CreateTenantResponse {
  /** @nullable */
  id?: string | null;
}

export interface DisableTenantResponse {
  /** @nullable */
  status?: string | null;
}

export interface FileUploadCommand {
  /** @nullable */
  name?: string | null;
  /** @nullable */
  extension?: string | null;
  /** @nullable */
  data?: string | null;
}

/**
 * @nullable
 */
export type FilterValue = unknown | null;

export interface Filter {
  /** @nullable */
  logic?: string | null;
  /** @nullable */
  filters?: Filter[] | null;
  /** @nullable */
  field?: string | null;
  /** @nullable */
  operator?: string | null;
  /** @nullable */
  value?: FilterValue;
}

export interface ForgotPasswordCommand {
  /** @nullable */
  email?: string | null;
}

export interface NeighborhoodResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  cityId?: string;
  /** @nullable */
  sphereImgURL?: string | null;
  /** @nullable */
  iconURL?: string | null;
  score?: number;
}

export interface NeighborhoodResponsePagedList {
  /** @nullable */
  items?: NeighborhoodResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface ProductResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  price?: number;
  brand?: BrandResponse;
}

export interface ProductResponsePagedList {
  /** @nullable */
  items?: ProductResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface PropertyResponse {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  address?: string | null;
  askingPrice?: number;
  size?: number;
  rooms?: number;
  bathrooms?: number;
  /** @nullable */
  neighborhoodName?: string | null;
  /** @nullable */
  propertyTypeName?: string | null;
  listedDate?: string;
  /** @nullable */
  soldDate?: string | null;
  /** @nullable */
  soldPrice?: number | null;
  /** @nullable */
  featureList?: string | null;
}

export interface PropertyResponsePagedList {
  /** @nullable */
  items?: PropertyResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface PropertyTypeResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface PropertyTypeResponsePagedList {
  /** @nullable */
  items?: PropertyTypeResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface RefreshTokenCommand {
  /** @nullable */
  token?: string | null;
  /** @nullable */
  refreshToken?: string | null;
}

export interface RegionResponse {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface RegionResponsePagedList {
  /** @nullable */
  items?: RegionResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface RegisterUserCommand {
  /** @nullable */
  firstName?: string | null;
  /** @nullable */
  lastName?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  userName?: string | null;
  /** @nullable */
  password?: string | null;
  /** @nullable */
  confirmPassword?: string | null;
  /** @nullable */
  phoneNumber?: string | null;
}

export interface RegisterUserResponse {
  /** @nullable */
  userId?: string | null;
}

export interface ResetPasswordCommand {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  password?: string | null;
  /** @nullable */
  token?: string | null;
}

export interface ReviewResponse {
  id?: string;
  /** @nullable */
  reviewer?: string | null;
  /** @nullable */
  content?: string | null;
  score?: number;
  reviewDate?: string;
}

export interface ReviewResponsePagedList {
  /** @nullable */
  items?: ReviewResponse[] | null;
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  readonly totalPages?: number;
  readonly hasPrevious?: boolean;
  readonly hasNext?: boolean;
}

export interface RoleDto {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  permissions?: string[] | null;
}

export interface Search {
  /** @nullable */
  fields?: string[] | null;
  /** @nullable */
  keyword?: string | null;
}

export interface SearchAgenciesCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface SearchBrandsCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface SearchCitiesCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  regionId?: string | null;
  /** @nullable */
  minimumRate?: number | null;
  /** @nullable */
  maximumRate?: number | null;
}

export interface SearchNeighborhoodsCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface SearchProductsCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  brandId?: string | null;
  /** @nullable */
  minimumRate?: number | null;
  /** @nullable */
  maximumRate?: number | null;
}

export interface SearchPropertiesCommand {
  advancedSearch?: Search;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  keyword?: string | null;
}

export interface SearchPropertyTypesCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface SearchRegionsCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface SearchReviewsCommand {
  advancedSearch?: Search;
  /** @nullable */
  keyword?: string | null;
  advancedFilter?: Filter;
  pageNumber?: number;
  pageSize?: number;
  /** @nullable */
  orderBy?: string[] | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface TenantDetail {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  connectionString?: string | null;
  /** @nullable */
  adminEmail?: string | null;
  isActive?: boolean;
  validUpto?: string;
  /** @nullable */
  issuer?: string | null;
}

export interface ToggleUserStatusCommand {
  activateUser?: boolean;
  /** @nullable */
  userId?: string | null;
}

export interface TokenGenerationCommand {
  /** @nullable */
  email?: string | null;
  /** @nullable */
  password?: string | null;
}

export interface TokenResponse {
  /** @nullable */
  token?: string | null;
  /** @nullable */
  refreshToken?: string | null;
  refreshTokenExpiryTime?: string;
}

export interface UpdateAgencyCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  telephone?: string | null;
  /** @nullable */
  address?: string | null;
  /** @nullable */
  logoURL?: string | null;
  /** @nullable */
  primaryColor?: string | null;
  /** @nullable */
  additionalInfo?: string | null;
}

export interface UpdateAgencyResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateBrandCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface UpdateBrandResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateCityCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  regionId?: string | null;
}

export interface UpdateCityResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateNeighborhoodCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  cityId?: string | null;
  /** @nullable */
  sphereImgURL?: string | null;
  /** @nullable */
  iconURL?: string | null;
  /** @nullable */
  score?: number | null;
}

export interface UpdateNeighborhoodResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdatePermissionsCommand {
  /** @nullable */
  roleId?: string | null;
  /** @nullable */
  permissions?: string[] | null;
}

export interface UpdateProductCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  price?: number;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  brandId?: string | null;
}

export interface UpdateProductResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdatePropertyCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  neighborhoodId?: string | null;
  /** @nullable */
  address?: string | null;
  /** @nullable */
  askingPrice?: number | null;
  /** @nullable */
  size?: number | null;
  /** @nullable */
  rooms?: number | null;
  /** @nullable */
  bathrooms?: number | null;
  /** @nullable */
  propertyTypeId?: string | null;
  /** @nullable */
  agencyId?: string | null;
  /** @nullable */
  listedDate?: string | null;
  /** @nullable */
  soldDate?: string | null;
  /** @nullable */
  soldPrice?: number | null;
  /** @nullable */
  featureList?: string | null;
}

export interface UpdatePropertyResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdatePropertyTypeCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface UpdatePropertyTypeResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateRegionCommand {
  id?: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
}

export interface UpdateRegionResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateReviewCommand {
  id?: string;
  /** @nullable */
  reviewer?: string | null;
  /** @nullable */
  content?: string | null;
  /** @nullable */
  score?: number | null;
  /** @nullable */
  reviewDate?: string | null;
  agencyId?: string;
}

export interface UpdateReviewResponse {
  /** @nullable */
  id?: string | null;
}

export interface UpdateUserCommand {
  /** @nullable */
  id?: string | null;
  /** @nullable */
  firstName?: string | null;
  /** @nullable */
  lastName?: string | null;
  /** @nullable */
  phoneNumber?: string | null;
  /** @nullable */
  email?: string | null;
  image?: FileUploadCommand;
  deleteCurrentImage?: boolean;
}

export interface UpgradeSubscriptionCommand {
  /** @nullable */
  tenant?: string | null;
  extendedExpiryDate?: string;
}

export interface UpgradeSubscriptionResponse {
  newValidity?: string;
  /** @nullable */
  tenant?: string | null;
}

export interface UserDetail {
  id?: string;
  /** @nullable */
  userName?: string | null;
  /** @nullable */
  firstName?: string | null;
  /** @nullable */
  lastName?: string | null;
  /** @nullable */
  email?: string | null;
  isActive?: boolean;
  emailConfirmed?: boolean;
  /** @nullable */
  phoneNumber?: string | null;
  /** @nullable */
  imageUrl?: string | null;
}

export interface UserRoleDetail {
  /** @nullable */
  roleId?: string | null;
  /** @nullable */
  roleName?: string | null;
  /** @nullable */
  description?: string | null;
  enabled?: boolean;
}

export type ConfirmEmailEndpointParams = {
userId: string;
code: string;
tenant: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * creates a Agency
 * @summary creates a Agency
 */
export const createAgencyEndpoint = (
    createAgencyCommand: BodyType<CreateAgencyCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAgencyResponse>(
      {url: `/api/v${version}/catalog/agencies`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAgencyCommand, signal
    },
      options);
    }
  


export const getCreateAgencyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAgencyEndpoint>>, TError,{data: BodyType<CreateAgencyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createAgencyEndpoint>>, TError,{data: BodyType<CreateAgencyCommand>;version?: string}, TContext> => {

const mutationKey = ['createAgencyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAgencyEndpoint>>, {data: BodyType<CreateAgencyCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createAgencyEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAgencyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createAgencyEndpoint>>>
    export type CreateAgencyEndpointMutationBody = BodyType<CreateAgencyCommand>
    export type CreateAgencyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary creates a Agency
 */
export const useCreateAgencyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAgencyEndpoint>>, TError,{data: BodyType<CreateAgencyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAgencyEndpoint>>,
        TError,
        {data: BodyType<CreateAgencyCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateAgencyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * gets Agency by id
 * @summary gets Agency by id
 */
export const getAgencyEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AgencyResponse>(
      {url: `/api/v${version}/catalog/agencies/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAgencyEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/agencies/${id}`] as const;
    }

    
export const getGetAgencyEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getAgencyEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgencyEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgencyEndpoint>>> = ({ signal }) => getAgencyEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgencyEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getAgencyEndpoint>>>
export type GetAgencyEndpointQueryError = ErrorType<unknown>


export function useGetAgencyEndpoint<TData = Awaited<ReturnType<typeof getAgencyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgencyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getAgencyEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgencyEndpoint<TData = Awaited<ReturnType<typeof getAgencyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgencyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getAgencyEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgencyEndpoint<TData = Awaited<ReturnType<typeof getAgencyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary gets Agency by id
 */

export function useGetAgencyEndpoint<TData = Awaited<ReturnType<typeof getAgencyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgencyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgencyEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * update a Agency
 * @summary update a Agency
 */
export const updateAgencyEndpoint = (
    id: string,
    updateAgencyCommand: BodyType<UpdateAgencyCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAgencyResponse>(
      {url: `/api/v${version}/catalog/agencies/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAgencyCommand
    },
      options);
    }
  


export const getUpdateAgencyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAgencyEndpoint>>, TError,{id: string;data: BodyType<UpdateAgencyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAgencyEndpoint>>, TError,{id: string;data: BodyType<UpdateAgencyCommand>;version?: string}, TContext> => {

const mutationKey = ['updateAgencyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAgencyEndpoint>>, {id: string;data: BodyType<UpdateAgencyCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateAgencyEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAgencyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateAgencyEndpoint>>>
    export type UpdateAgencyEndpointMutationBody = BodyType<UpdateAgencyCommand>
    export type UpdateAgencyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary update a Agency
 */
export const useUpdateAgencyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAgencyEndpoint>>, TError,{id: string;data: BodyType<UpdateAgencyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAgencyEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateAgencyCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateAgencyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * deletes Agency by id
 * @summary deletes Agency by id
 */
export const deleteAgencyEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/agencies/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAgencyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAgencyEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAgencyEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteAgencyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAgencyEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteAgencyEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAgencyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAgencyEndpoint>>>
    
    export type DeleteAgencyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary deletes Agency by id
 */
export const useDeleteAgencyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAgencyEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAgencyEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteAgencyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a list of Agencies with pagination and filtering support
 * @summary Gets a list of Agencies
 */
export const searchAgenciesEndpoint = (
    searchAgenciesCommand: BodyType<SearchAgenciesCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AgencyResponsePagedList>(
      {url: `/api/v${version}/catalog/agencies/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchAgenciesCommand, signal
    },
      options);
    }
  


export const getSearchAgenciesEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchAgenciesEndpoint>>, TError,{data: BodyType<SearchAgenciesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchAgenciesEndpoint>>, TError,{data: BodyType<SearchAgenciesCommand>;version?: string}, TContext> => {

const mutationKey = ['searchAgenciesEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchAgenciesEndpoint>>, {data: BodyType<SearchAgenciesCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchAgenciesEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchAgenciesEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchAgenciesEndpoint>>>
    export type SearchAgenciesEndpointMutationBody = BodyType<SearchAgenciesCommand>
    export type SearchAgenciesEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Gets a list of Agencies
 */
export const useSearchAgenciesEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchAgenciesEndpoint>>, TError,{data: BodyType<SearchAgenciesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchAgenciesEndpoint>>,
        TError,
        {data: BodyType<SearchAgenciesCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchAgenciesEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * creates a brand
 * @summary creates a brand
 */
export const createBrandEndpoint = (
    createBrandCommand: BodyType<CreateBrandCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateBrandResponse>(
      {url: `/api/v${version}/catalog/brands`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBrandCommand, signal
    },
      options);
    }
  


export const getCreateBrandEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandEndpoint>>, TError,{data: BodyType<CreateBrandCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createBrandEndpoint>>, TError,{data: BodyType<CreateBrandCommand>;version?: string}, TContext> => {

const mutationKey = ['createBrandEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrandEndpoint>>, {data: BodyType<CreateBrandCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createBrandEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBrandEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createBrandEndpoint>>>
    export type CreateBrandEndpointMutationBody = BodyType<CreateBrandCommand>
    export type CreateBrandEndpointMutationError = ErrorType<unknown>

    /**
 * @summary creates a brand
 */
export const useCreateBrandEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandEndpoint>>, TError,{data: BodyType<CreateBrandCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBrandEndpoint>>,
        TError,
        {data: BodyType<CreateBrandCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateBrandEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * gets brand by id
 * @summary gets brand by id
 */
export const getBrandEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BrandResponse>(
      {url: `/api/v${version}/catalog/brands/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetBrandEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/brands/${id}`] as const;
    }

    
export const getGetBrandEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getBrandEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBrandEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrandEndpoint>>> = ({ signal }) => getBrandEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetBrandEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getBrandEndpoint>>>
export type GetBrandEndpointQueryError = ErrorType<unknown>


export function useGetBrandEndpoint<TData = Awaited<ReturnType<typeof getBrandEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrandEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getBrandEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBrandEndpoint<TData = Awaited<ReturnType<typeof getBrandEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrandEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getBrandEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetBrandEndpoint<TData = Awaited<ReturnType<typeof getBrandEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary gets brand by id
 */

export function useGetBrandEndpoint<TData = Awaited<ReturnType<typeof getBrandEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrandEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetBrandEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * update a brand
 * @summary update a brand
 */
export const updateBrandEndpoint = (
    id: string,
    updateBrandCommand: BodyType<UpdateBrandCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateBrandResponse>(
      {url: `/api/v${version}/catalog/brands/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateBrandCommand
    },
      options);
    }
  


export const getUpdateBrandEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBrandEndpoint>>, TError,{id: string;data: BodyType<UpdateBrandCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBrandEndpoint>>, TError,{id: string;data: BodyType<UpdateBrandCommand>;version?: string}, TContext> => {

const mutationKey = ['updateBrandEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBrandEndpoint>>, {id: string;data: BodyType<UpdateBrandCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateBrandEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBrandEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateBrandEndpoint>>>
    export type UpdateBrandEndpointMutationBody = BodyType<UpdateBrandCommand>
    export type UpdateBrandEndpointMutationError = ErrorType<unknown>

    /**
 * @summary update a brand
 */
export const useUpdateBrandEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBrandEndpoint>>, TError,{id: string;data: BodyType<UpdateBrandCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBrandEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateBrandCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateBrandEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * deletes brand by id
 * @summary deletes brand by id
 */
export const deleteBrandEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/brands/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteBrandEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBrandEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBrandEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteBrandEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBrandEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteBrandEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBrandEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBrandEndpoint>>>
    
    export type DeleteBrandEndpointMutationError = ErrorType<unknown>

    /**
 * @summary deletes brand by id
 */
export const useDeleteBrandEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBrandEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBrandEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteBrandEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a list of brands with pagination and filtering support
 * @summary Gets a list of brands
 */
export const searchBrandsEndpoint = (
    searchBrandsCommand: BodyType<SearchBrandsCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BrandResponsePagedList>(
      {url: `/api/v${version}/catalog/brands/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchBrandsCommand, signal
    },
      options);
    }
  


export const getSearchBrandsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchBrandsEndpoint>>, TError,{data: BodyType<SearchBrandsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchBrandsEndpoint>>, TError,{data: BodyType<SearchBrandsCommand>;version?: string}, TContext> => {

const mutationKey = ['searchBrandsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchBrandsEndpoint>>, {data: BodyType<SearchBrandsCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchBrandsEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchBrandsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchBrandsEndpoint>>>
    export type SearchBrandsEndpointMutationBody = BodyType<SearchBrandsCommand>
    export type SearchBrandsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Gets a list of brands
 */
export const useSearchBrandsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchBrandsEndpoint>>, TError,{data: BodyType<SearchBrandsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchBrandsEndpoint>>,
        TError,
        {data: BodyType<SearchBrandsCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchBrandsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a City
 * @summary Creates a City
 */
export const createCityEndpoint = (
    createCityCommand: BodyType<CreateCityCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateCityResponse>(
      {url: `/api/v${version}/catalog/cities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCityCommand, signal
    },
      options);
    }
  


export const getCreateCityEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCityEndpoint>>, TError,{data: BodyType<CreateCityCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCityEndpoint>>, TError,{data: BodyType<CreateCityCommand>;version?: string}, TContext> => {

const mutationKey = ['createCityEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCityEndpoint>>, {data: BodyType<CreateCityCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createCityEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCityEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createCityEndpoint>>>
    export type CreateCityEndpointMutationBody = BodyType<CreateCityCommand>
    export type CreateCityEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a City
 */
export const useCreateCityEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCityEndpoint>>, TError,{data: BodyType<CreateCityCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCityEndpoint>>,
        TError,
        {data: BodyType<CreateCityCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateCityEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a City by ID
 * @summary Gets a City by ID
 */
export const getCityEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CityResponse>(
      {url: `/api/v${version}/catalog/cities/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCityEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/cities/${id}`] as const;
    }

    
export const getGetCityEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getCityEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCityEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCityEndpoint>>> = ({ signal }) => getCityEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCityEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getCityEndpoint>>>
export type GetCityEndpointQueryError = ErrorType<unknown>


export function useGetCityEndpoint<TData = Awaited<ReturnType<typeof getCityEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCityEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getCityEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCityEndpoint<TData = Awaited<ReturnType<typeof getCityEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCityEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getCityEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCityEndpoint<TData = Awaited<ReturnType<typeof getCityEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a City by ID
 */

export function useGetCityEndpoint<TData = Awaited<ReturnType<typeof getCityEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCityEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCityEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a City
 * @summary Updates a City
 */
export const updateCityEndpoint = (
    id: string,
    updateCityCommand: BodyType<UpdateCityCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateCityResponse>(
      {url: `/api/v${version}/catalog/cities/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateCityCommand
    },
      options);
    }
  


export const getUpdateCityEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCityEndpoint>>, TError,{id: string;data: BodyType<UpdateCityCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCityEndpoint>>, TError,{id: string;data: BodyType<UpdateCityCommand>;version?: string}, TContext> => {

const mutationKey = ['updateCityEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCityEndpoint>>, {id: string;data: BodyType<UpdateCityCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateCityEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCityEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateCityEndpoint>>>
    export type UpdateCityEndpointMutationBody = BodyType<UpdateCityCommand>
    export type UpdateCityEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a City
 */
export const useUpdateCityEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCityEndpoint>>, TError,{id: string;data: BodyType<UpdateCityCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCityEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateCityCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateCityEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a City by ID
 * @summary Deletes a City by ID
 */
export const deleteCityEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/cities/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCityEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCityEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCityEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteCityEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCityEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteCityEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCityEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCityEndpoint>>>
    
    export type DeleteCityEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a City by ID
 */
export const useDeleteCityEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCityEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCityEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteCityEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Searches Cities with pagination and filtering
 * @summary Searches Cities with pagination and filtering
 */
export const searchCitiesEndpoint = (
    searchCitiesCommand: BodyType<SearchCitiesCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CityResponsePagedList>(
      {url: `/api/v${version}/catalog/cities/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchCitiesCommand, signal
    },
      options);
    }
  


export const getSearchCitiesEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCitiesEndpoint>>, TError,{data: BodyType<SearchCitiesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchCitiesEndpoint>>, TError,{data: BodyType<SearchCitiesCommand>;version?: string}, TContext> => {

const mutationKey = ['searchCitiesEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchCitiesEndpoint>>, {data: BodyType<SearchCitiesCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchCitiesEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchCitiesEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchCitiesEndpoint>>>
    export type SearchCitiesEndpointMutationBody = BodyType<SearchCitiesCommand>
    export type SearchCitiesEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Searches Cities with pagination and filtering
 */
export const useSearchCitiesEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchCitiesEndpoint>>, TError,{data: BodyType<SearchCitiesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchCitiesEndpoint>>,
        TError,
        {data: BodyType<SearchCitiesCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchCitiesEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a Neighborhood
 * @summary Creates a Neighborhood
 */
export const createNeighborhoodEndpoint = (
    createNeighborhoodCommand: BodyType<CreateNeighborhoodCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateNeighborhoodResponse>(
      {url: `/api/v${version}/catalog/neighborhoods`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createNeighborhoodCommand, signal
    },
      options);
    }
  


export const getCreateNeighborhoodEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNeighborhoodEndpoint>>, TError,{data: BodyType<CreateNeighborhoodCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNeighborhoodEndpoint>>, TError,{data: BodyType<CreateNeighborhoodCommand>;version?: string}, TContext> => {

const mutationKey = ['createNeighborhoodEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNeighborhoodEndpoint>>, {data: BodyType<CreateNeighborhoodCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createNeighborhoodEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNeighborhoodEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createNeighborhoodEndpoint>>>
    export type CreateNeighborhoodEndpointMutationBody = BodyType<CreateNeighborhoodCommand>
    export type CreateNeighborhoodEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a Neighborhood
 */
export const useCreateNeighborhoodEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNeighborhoodEndpoint>>, TError,{data: BodyType<CreateNeighborhoodCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNeighborhoodEndpoint>>,
        TError,
        {data: BodyType<CreateNeighborhoodCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateNeighborhoodEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a Neighborhood by ID
 * @summary Gets a Neighborhood by ID
 */
export const getNeighborhoodEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NeighborhoodResponse>(
      {url: `/api/v${version}/catalog/neighborhoods/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNeighborhoodEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/neighborhoods/${id}`] as const;
    }

    
export const getGetNeighborhoodEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNeighborhoodEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>> = ({ signal }) => getNeighborhoodEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNeighborhoodEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>>
export type GetNeighborhoodEndpointQueryError = ErrorType<unknown>


export function useGetNeighborhoodEndpoint<TData = Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNeighborhoodEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getNeighborhoodEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNeighborhoodEndpoint<TData = Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNeighborhoodEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getNeighborhoodEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNeighborhoodEndpoint<TData = Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a Neighborhood by ID
 */

export function useGetNeighborhoodEndpoint<TData = Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNeighborhoodEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNeighborhoodEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a Neighborhood
 * @summary Updates a Neighborhood
 */
export const updateNeighborhoodEndpoint = (
    id: string,
    updateNeighborhoodCommand: BodyType<UpdateNeighborhoodCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateNeighborhoodResponse>(
      {url: `/api/v${version}/catalog/neighborhoods/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateNeighborhoodCommand
    },
      options);
    }
  


export const getUpdateNeighborhoodEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>, TError,{id: string;data: BodyType<UpdateNeighborhoodCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>, TError,{id: string;data: BodyType<UpdateNeighborhoodCommand>;version?: string}, TContext> => {

const mutationKey = ['updateNeighborhoodEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>, {id: string;data: BodyType<UpdateNeighborhoodCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateNeighborhoodEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNeighborhoodEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>>
    export type UpdateNeighborhoodEndpointMutationBody = BodyType<UpdateNeighborhoodCommand>
    export type UpdateNeighborhoodEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a Neighborhood
 */
export const useUpdateNeighborhoodEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>, TError,{id: string;data: BodyType<UpdateNeighborhoodCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNeighborhoodEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateNeighborhoodCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateNeighborhoodEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a Neighborhood by ID
 * @summary Deletes a Neighborhood by ID
 */
export const deleteNeighborhoodEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/neighborhoods/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNeighborhoodEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteNeighborhoodEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteNeighborhoodEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNeighborhoodEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>>
    
    export type DeleteNeighborhoodEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a Neighborhood by ID
 */
export const useDeleteNeighborhoodEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNeighborhoodEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteNeighborhoodEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Searches Neighborhoods with pagination and filtering
 * @summary Searches Neighborhoods with pagination and filtering
 */
export const searchNeighborhoodsEndpoint = (
    searchNeighborhoodsCommand: BodyType<SearchNeighborhoodsCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NeighborhoodResponsePagedList>(
      {url: `/api/v${version}/catalog/neighborhoods/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchNeighborhoodsCommand, signal
    },
      options);
    }
  


export const getSearchNeighborhoodsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>, TError,{data: BodyType<SearchNeighborhoodsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>, TError,{data: BodyType<SearchNeighborhoodsCommand>;version?: string}, TContext> => {

const mutationKey = ['searchNeighborhoodsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>, {data: BodyType<SearchNeighborhoodsCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchNeighborhoodsEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchNeighborhoodsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>>
    export type SearchNeighborhoodsEndpointMutationBody = BodyType<SearchNeighborhoodsCommand>
    export type SearchNeighborhoodsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Searches Neighborhoods with pagination and filtering
 */
export const useSearchNeighborhoodsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>, TError,{data: BodyType<SearchNeighborhoodsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchNeighborhoodsEndpoint>>,
        TError,
        {data: BodyType<SearchNeighborhoodsCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchNeighborhoodsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * creates a product
 * @summary creates a product
 */
export const createProductEndpoint = (
    createProductCommand: BodyType<CreateProductCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateProductResponse>(
      {url: `/api/v${version}/catalog/products`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createProductCommand, signal
    },
      options);
    }
  


export const getCreateProductEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProductEndpoint>>, TError,{data: BodyType<CreateProductCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProductEndpoint>>, TError,{data: BodyType<CreateProductCommand>;version?: string}, TContext> => {

const mutationKey = ['createProductEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProductEndpoint>>, {data: BodyType<CreateProductCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createProductEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createProductEndpoint>>>
    export type CreateProductEndpointMutationBody = BodyType<CreateProductCommand>
    export type CreateProductEndpointMutationError = ErrorType<unknown>

    /**
 * @summary creates a product
 */
export const useCreateProductEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProductEndpoint>>, TError,{data: BodyType<CreateProductCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProductEndpoint>>,
        TError,
        {data: BodyType<CreateProductCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateProductEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * gets prodct by id
 * @summary gets product by id
 */
export const getProductEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductResponse>(
      {url: `/api/v${version}/catalog/products/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetProductEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/products/${id}`] as const;
    }

    
export const getGetProductEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getProductEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductEndpoint>>> = ({ signal }) => getProductEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProductEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getProductEndpoint>>>
export type GetProductEndpointQueryError = ErrorType<unknown>


export function useGetProductEndpoint<TData = Awaited<ReturnType<typeof getProductEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getProductEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductEndpoint<TData = Awaited<ReturnType<typeof getProductEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getProductEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProductEndpoint<TData = Awaited<ReturnType<typeof getProductEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary gets product by id
 */

export function useGetProductEndpoint<TData = Awaited<ReturnType<typeof getProductEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProductEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * update a product
 * @summary update a product
 */
export const updateProductEndpoint = (
    id: string,
    updateProductCommand: BodyType<UpdateProductCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateProductResponse>(
      {url: `/api/v${version}/catalog/products/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateProductCommand
    },
      options);
    }
  


export const getUpdateProductEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProductEndpoint>>, TError,{id: string;data: BodyType<UpdateProductCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProductEndpoint>>, TError,{id: string;data: BodyType<UpdateProductCommand>;version?: string}, TContext> => {

const mutationKey = ['updateProductEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductEndpoint>>, {id: string;data: BodyType<UpdateProductCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateProductEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProductEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductEndpoint>>>
    export type UpdateProductEndpointMutationBody = BodyType<UpdateProductCommand>
    export type UpdateProductEndpointMutationError = ErrorType<unknown>

    /**
 * @summary update a product
 */
export const useUpdateProductEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProductEndpoint>>, TError,{id: string;data: BodyType<UpdateProductCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProductEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateProductCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateProductEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * deletes product by id
 * @summary deletes product by id
 */
export const deleteProductEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/products/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProductEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteProductEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteProductEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductEndpoint>>>
    
    export type DeleteProductEndpointMutationError = ErrorType<unknown>

    /**
 * @summary deletes product by id
 */
export const useDeleteProductEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProductEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a list of products with pagination and filtering support
 * @summary Gets a list of products
 */
export const searchProductsEndpoint = (
    searchProductsCommand: BodyType<SearchProductsCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProductResponsePagedList>(
      {url: `/api/v${version}/catalog/products/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchProductsCommand, signal
    },
      options);
    }
  


export const getSearchProductsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchProductsEndpoint>>, TError,{data: BodyType<SearchProductsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchProductsEndpoint>>, TError,{data: BodyType<SearchProductsCommand>;version?: string}, TContext> => {

const mutationKey = ['searchProductsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchProductsEndpoint>>, {data: BodyType<SearchProductsCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchProductsEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchProductsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchProductsEndpoint>>>
    export type SearchProductsEndpointMutationBody = BodyType<SearchProductsCommand>
    export type SearchProductsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Gets a list of products
 */
export const useSearchProductsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchProductsEndpoint>>, TError,{data: BodyType<SearchProductsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchProductsEndpoint>>,
        TError,
        {data: BodyType<SearchProductsCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchProductsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a new Property
 * @summary Creates a new Property
 */
export const createPropertyEndpoint = (
    createPropertyCommand: BodyType<CreatePropertyCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreatePropertyResponse>(
      {url: `/api/v${version}/catalog/properties`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPropertyCommand, signal
    },
      options);
    }
  


export const getCreatePropertyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPropertyEndpoint>>, TError,{data: BodyType<CreatePropertyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPropertyEndpoint>>, TError,{data: BodyType<CreatePropertyCommand>;version?: string}, TContext> => {

const mutationKey = ['createPropertyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPropertyEndpoint>>, {data: BodyType<CreatePropertyCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createPropertyEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePropertyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createPropertyEndpoint>>>
    export type CreatePropertyEndpointMutationBody = BodyType<CreatePropertyCommand>
    export type CreatePropertyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a new Property
 */
export const useCreatePropertyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPropertyEndpoint>>, TError,{data: BodyType<CreatePropertyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPropertyEndpoint>>,
        TError,
        {data: BodyType<CreatePropertyCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreatePropertyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a Property by ID
 * @summary Gets a Property by ID
 */
export const getPropertyEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PropertyResponse>(
      {url: `/api/v${version}/catalog/properties/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPropertyEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/properties/${id}`] as const;
    }

    
export const getGetPropertyEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getPropertyEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPropertyEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPropertyEndpoint>>> = ({ signal }) => getPropertyEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPropertyEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getPropertyEndpoint>>>
export type GetPropertyEndpointQueryError = ErrorType<unknown>


export function useGetPropertyEndpoint<TData = Awaited<ReturnType<typeof getPropertyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getPropertyEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPropertyEndpoint<TData = Awaited<ReturnType<typeof getPropertyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getPropertyEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPropertyEndpoint<TData = Awaited<ReturnType<typeof getPropertyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a Property by ID
 */

export function useGetPropertyEndpoint<TData = Awaited<ReturnType<typeof getPropertyEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPropertyEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a Property
 * @summary Updates a Property
 */
export const updatePropertyEndpoint = (
    id: string,
    updatePropertyCommand: BodyType<UpdatePropertyCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdatePropertyResponse>(
      {url: `/api/v${version}/catalog/properties/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePropertyCommand
    },
      options);
    }
  


export const getUpdatePropertyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePropertyEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePropertyEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyCommand>;version?: string}, TContext> => {

const mutationKey = ['updatePropertyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePropertyEndpoint>>, {id: string;data: BodyType<UpdatePropertyCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updatePropertyEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePropertyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updatePropertyEndpoint>>>
    export type UpdatePropertyEndpointMutationBody = BodyType<UpdatePropertyCommand>
    export type UpdatePropertyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a Property
 */
export const useUpdatePropertyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePropertyEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePropertyEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdatePropertyCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdatePropertyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a Property
 * @summary Deletes a Property
 */
export const deletePropertyEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/properties/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePropertyEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePropertyEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePropertyEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deletePropertyEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePropertyEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deletePropertyEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePropertyEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deletePropertyEndpoint>>>
    
    export type DeletePropertyEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a Property
 */
export const useDeletePropertyEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePropertyEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePropertyEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeletePropertyEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a list of Properties with pagination and filtering support
 * @summary Gets a list of Properties
 */
export const searchPropertiesEndpoint = (
    searchPropertiesCommand: BodyType<SearchPropertiesCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PropertyResponsePagedList>(
      {url: `/api/v${version}/catalog/properties/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchPropertiesCommand, signal
    },
      options);
    }
  


export const getSearchPropertiesEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPropertiesEndpoint>>, TError,{data: BodyType<SearchPropertiesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchPropertiesEndpoint>>, TError,{data: BodyType<SearchPropertiesCommand>;version?: string}, TContext> => {

const mutationKey = ['searchPropertiesEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchPropertiesEndpoint>>, {data: BodyType<SearchPropertiesCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchPropertiesEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchPropertiesEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchPropertiesEndpoint>>>
    export type SearchPropertiesEndpointMutationBody = BodyType<SearchPropertiesCommand>
    export type SearchPropertiesEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Gets a list of Properties
 */
export const useSearchPropertiesEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPropertiesEndpoint>>, TError,{data: BodyType<SearchPropertiesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchPropertiesEndpoint>>,
        TError,
        {data: BodyType<SearchPropertiesCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchPropertiesEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a PropertyType
 * @summary Creates a PropertyType
 */
export const createPropertyTypeEndpoint = (
    createPropertyTypeCommand: BodyType<CreatePropertyTypeCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreatePropertyTypeResponse>(
      {url: `/api/v${version}/catalog/propertytypes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createPropertyTypeCommand, signal
    },
      options);
    }
  


export const getCreatePropertyTypeEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPropertyTypeEndpoint>>, TError,{data: BodyType<CreatePropertyTypeCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPropertyTypeEndpoint>>, TError,{data: BodyType<CreatePropertyTypeCommand>;version?: string}, TContext> => {

const mutationKey = ['createPropertyTypeEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPropertyTypeEndpoint>>, {data: BodyType<CreatePropertyTypeCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createPropertyTypeEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePropertyTypeEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createPropertyTypeEndpoint>>>
    export type CreatePropertyTypeEndpointMutationBody = BodyType<CreatePropertyTypeCommand>
    export type CreatePropertyTypeEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a PropertyType
 */
export const useCreatePropertyTypeEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPropertyTypeEndpoint>>, TError,{data: BodyType<CreatePropertyTypeCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPropertyTypeEndpoint>>,
        TError,
        {data: BodyType<CreatePropertyTypeCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreatePropertyTypeEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a PropertyType by ID
 * @summary Gets a PropertyType by ID
 */
export const getPropertyTypeEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PropertyTypeResponse>(
      {url: `/api/v${version}/catalog/propertytypes/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPropertyTypeEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/propertytypes/${id}`] as const;
    }

    
export const getGetPropertyTypeEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPropertyTypeEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>> = ({ signal }) => getPropertyTypeEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPropertyTypeEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>>
export type GetPropertyTypeEndpointQueryError = ErrorType<unknown>


export function useGetPropertyTypeEndpoint<TData = Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyTypeEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getPropertyTypeEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPropertyTypeEndpoint<TData = Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyTypeEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getPropertyTypeEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPropertyTypeEndpoint<TData = Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a PropertyType by ID
 */

export function useGetPropertyTypeEndpoint<TData = Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPropertyTypeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPropertyTypeEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a PropertyType
 * @summary Updates a PropertyType
 */
export const updatePropertyTypeEndpoint = (
    id: string,
    updatePropertyTypeCommand: BodyType<UpdatePropertyTypeCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdatePropertyTypeResponse>(
      {url: `/api/v${version}/catalog/propertytypes/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePropertyTypeCommand
    },
      options);
    }
  


export const getUpdatePropertyTypeEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyTypeCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyTypeCommand>;version?: string}, TContext> => {

const mutationKey = ['updatePropertyTypeEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>, {id: string;data: BodyType<UpdatePropertyTypeCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updatePropertyTypeEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePropertyTypeEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>>
    export type UpdatePropertyTypeEndpointMutationBody = BodyType<UpdatePropertyTypeCommand>
    export type UpdatePropertyTypeEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a PropertyType
 */
export const useUpdatePropertyTypeEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>, TError,{id: string;data: BodyType<UpdatePropertyTypeCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePropertyTypeEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdatePropertyTypeCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdatePropertyTypeEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a PropertyType by ID
 * @summary Deletes a PropertyType by ID
 */
export const deletePropertyTypeEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/propertytypes/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePropertyTypeEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deletePropertyTypeEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deletePropertyTypeEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePropertyTypeEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>>
    
    export type DeletePropertyTypeEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a PropertyType by ID
 */
export const useDeletePropertyTypeEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePropertyTypeEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeletePropertyTypeEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Searches PropertyTypes with pagination and filtering
 * @summary Searches PropertyTypes with pagination and filtering
 */
export const searchPropertyTypesEndpoint = (
    searchPropertyTypesCommand: BodyType<SearchPropertyTypesCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PropertyTypeResponsePagedList>(
      {url: `/api/v${version}/catalog/propertytypes/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchPropertyTypesCommand, signal
    },
      options);
    }
  


export const getSearchPropertyTypesEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>, TError,{data: BodyType<SearchPropertyTypesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>, TError,{data: BodyType<SearchPropertyTypesCommand>;version?: string}, TContext> => {

const mutationKey = ['searchPropertyTypesEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>, {data: BodyType<SearchPropertyTypesCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchPropertyTypesEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchPropertyTypesEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>>
    export type SearchPropertyTypesEndpointMutationBody = BodyType<SearchPropertyTypesCommand>
    export type SearchPropertyTypesEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Searches PropertyTypes with pagination and filtering
 */
export const useSearchPropertyTypesEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>, TError,{data: BodyType<SearchPropertyTypesCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchPropertyTypesEndpoint>>,
        TError,
        {data: BodyType<SearchPropertyTypesCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchPropertyTypesEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a Region
 * @summary Creates a Region
 */
export const createRegionEndpoint = (
    createRegionCommand: BodyType<CreateRegionCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateRegionResponse>(
      {url: `/api/v${version}/catalog/regions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createRegionCommand, signal
    },
      options);
    }
  


export const getCreateRegionEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRegionEndpoint>>, TError,{data: BodyType<CreateRegionCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createRegionEndpoint>>, TError,{data: BodyType<CreateRegionCommand>;version?: string}, TContext> => {

const mutationKey = ['createRegionEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRegionEndpoint>>, {data: BodyType<CreateRegionCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createRegionEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRegionEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createRegionEndpoint>>>
    export type CreateRegionEndpointMutationBody = BodyType<CreateRegionCommand>
    export type CreateRegionEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a Region
 */
export const useCreateRegionEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRegionEndpoint>>, TError,{data: BodyType<CreateRegionCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRegionEndpoint>>,
        TError,
        {data: BodyType<CreateRegionCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateRegionEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a Region by ID
 * @summary Gets a Region by ID
 */
export const getRegionEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RegionResponse>(
      {url: `/api/v${version}/catalog/regions/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRegionEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/regions/${id}`] as const;
    }

    
export const getGetRegionEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getRegionEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRegionEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRegionEndpoint>>> = ({ signal }) => getRegionEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRegionEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getRegionEndpoint>>>
export type GetRegionEndpointQueryError = ErrorType<unknown>


export function useGetRegionEndpoint<TData = Awaited<ReturnType<typeof getRegionEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRegionEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRegionEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRegionEndpoint<TData = Awaited<ReturnType<typeof getRegionEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRegionEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRegionEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRegionEndpoint<TData = Awaited<ReturnType<typeof getRegionEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a Region by ID
 */

export function useGetRegionEndpoint<TData = Awaited<ReturnType<typeof getRegionEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRegionEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRegionEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a Region
 * @summary Updates a Region
 */
export const updateRegionEndpoint = (
    id: string,
    updateRegionCommand: BodyType<UpdateRegionCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRegionResponse>(
      {url: `/api/v${version}/catalog/regions/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateRegionCommand
    },
      options);
    }
  


export const getUpdateRegionEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRegionEndpoint>>, TError,{id: string;data: BodyType<UpdateRegionCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRegionEndpoint>>, TError,{id: string;data: BodyType<UpdateRegionCommand>;version?: string}, TContext> => {

const mutationKey = ['updateRegionEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRegionEndpoint>>, {id: string;data: BodyType<UpdateRegionCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateRegionEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRegionEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateRegionEndpoint>>>
    export type UpdateRegionEndpointMutationBody = BodyType<UpdateRegionCommand>
    export type UpdateRegionEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a Region
 */
export const useUpdateRegionEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRegionEndpoint>>, TError,{id: string;data: BodyType<UpdateRegionCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRegionEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateRegionCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateRegionEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a Region by ID
 * @summary Deletes a Region by ID
 */
export const deleteRegionEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/regions/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRegionEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRegionEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRegionEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteRegionEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRegionEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteRegionEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRegionEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRegionEndpoint>>>
    
    export type DeleteRegionEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a Region by ID
 */
export const useDeleteRegionEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRegionEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRegionEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteRegionEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Searches Regions with pagination and filtering
 * @summary Searches Regions with pagination and filtering
 */
export const searchRegionsEndpoint = (
    searchRegionsCommand: BodyType<SearchRegionsCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RegionResponsePagedList>(
      {url: `/api/v${version}/catalog/regions/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchRegionsCommand, signal
    },
      options);
    }
  


export const getSearchRegionsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchRegionsEndpoint>>, TError,{data: BodyType<SearchRegionsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchRegionsEndpoint>>, TError,{data: BodyType<SearchRegionsCommand>;version?: string}, TContext> => {

const mutationKey = ['searchRegionsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchRegionsEndpoint>>, {data: BodyType<SearchRegionsCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchRegionsEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchRegionsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchRegionsEndpoint>>>
    export type SearchRegionsEndpointMutationBody = BodyType<SearchRegionsCommand>
    export type SearchRegionsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Searches Regions with pagination and filtering
 */
export const useSearchRegionsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchRegionsEndpoint>>, TError,{data: BodyType<SearchRegionsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchRegionsEndpoint>>,
        TError,
        {data: BodyType<SearchRegionsCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchRegionsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Creates a Review
 * @summary Creates a Review
 */
export const createReviewEndpoint = (
    createReviewCommand: BodyType<CreateReviewCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateReviewResponse>(
      {url: `/api/v${version}/catalog/reviews`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createReviewCommand, signal
    },
      options);
    }
  


export const getCreateReviewEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReviewEndpoint>>, TError,{data: BodyType<CreateReviewCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createReviewEndpoint>>, TError,{data: BodyType<CreateReviewCommand>;version?: string}, TContext> => {

const mutationKey = ['createReviewEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReviewEndpoint>>, {data: BodyType<CreateReviewCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  createReviewEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createReviewEndpoint>>>
    export type CreateReviewEndpointMutationBody = BodyType<CreateReviewCommand>
    export type CreateReviewEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Creates a Review
 */
export const useCreateReviewEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReviewEndpoint>>, TError,{data: BodyType<CreateReviewCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReviewEndpoint>>,
        TError,
        {data: BodyType<CreateReviewCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getCreateReviewEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Gets a Review by ID
 * @summary Gets a Review by ID
 */
export const getReviewEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ReviewResponse>(
      {url: `/api/v${version}/catalog/reviews/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetReviewEndpointQueryKey = (id: string,
    version: string = '1',) => {
    return [`/api/v${version}/catalog/reviews/${id}`] as const;
    }

    
export const getGetReviewEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getReviewEndpoint>>, TError = ErrorType<unknown>>(id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewEndpointQueryKey(id,version);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewEndpoint>>> = ({ signal }) => getReviewEndpoint(id,version, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(version && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetReviewEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewEndpoint>>>
export type GetReviewEndpointQueryError = ErrorType<unknown>


export function useGetReviewEndpoint<TData = Awaited<ReturnType<typeof getReviewEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getReviewEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetReviewEndpoint<TData = Awaited<ReturnType<typeof getReviewEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getReviewEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetReviewEndpoint<TData = Awaited<ReturnType<typeof getReviewEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Gets a Review by ID
 */

export function useGetReviewEndpoint<TData = Awaited<ReturnType<typeof getReviewEndpoint>>, TError = ErrorType<unknown>>(
 id: string,
    version: string = '1', options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetReviewEndpointQueryOptions(id,version,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Updates a Review
 * @summary Updates a Review
 */
export const updateReviewEndpoint = (
    id: string,
    updateReviewCommand: BodyType<UpdateReviewCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateReviewResponse>(
      {url: `/api/v${version}/catalog/reviews/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateReviewCommand
    },
      options);
    }
  


export const getUpdateReviewEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReviewEndpoint>>, TError,{id: string;data: BodyType<UpdateReviewCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateReviewEndpoint>>, TError,{id: string;data: BodyType<UpdateReviewCommand>;version?: string}, TContext> => {

const mutationKey = ['updateReviewEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateReviewEndpoint>>, {id: string;data: BodyType<UpdateReviewCommand>;version?: string}> = (props) => {
          const {id,data,version} = props ?? {};

          return  updateReviewEndpoint(id,data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateReviewEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateReviewEndpoint>>>
    export type UpdateReviewEndpointMutationBody = BodyType<UpdateReviewCommand>
    export type UpdateReviewEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Updates a Review
 */
export const useUpdateReviewEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateReviewEndpoint>>, TError,{id: string;data: BodyType<UpdateReviewCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateReviewEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdateReviewCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getUpdateReviewEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Deletes a Review by ID
 * @summary Deletes a Review by ID
 */
export const deleteReviewEndpoint = (
    id: string,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v${version}/catalog/reviews/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteReviewEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteReviewEndpoint>>, TError,{id: string;version?: string}, TContext> => {

const mutationKey = ['deleteReviewEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReviewEndpoint>>, {id: string;version?: string}> = (props) => {
          const {id,version} = props ?? {};

          return  deleteReviewEndpoint(id,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReviewEndpoint>>>
    
    export type DeleteReviewEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Deletes a Review by ID
 */
export const useDeleteReviewEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewEndpoint>>, TError,{id: string;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteReviewEndpoint>>,
        TError,
        {id: string;version?: string},
        TContext
      > => {

      const mutationOptions = getDeleteReviewEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Searches Reviews with pagination and filtering
 * @summary Searches Reviews with pagination and filtering
 */
export const searchReviewsEndpoint = (
    searchReviewsCommand: BodyType<SearchReviewsCommand>,
    version: string = '1',
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ReviewResponsePagedList>(
      {url: `/api/v${version}/catalog/reviews/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchReviewsCommand, signal
    },
      options);
    }
  


export const getSearchReviewsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewsEndpoint>>, TError,{data: BodyType<SearchReviewsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof searchReviewsEndpoint>>, TError,{data: BodyType<SearchReviewsCommand>;version?: string}, TContext> => {

const mutationKey = ['searchReviewsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchReviewsEndpoint>>, {data: BodyType<SearchReviewsCommand>;version?: string}> = (props) => {
          const {data,version} = props ?? {};

          return  searchReviewsEndpoint(data,version,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchReviewsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof searchReviewsEndpoint>>>
    export type SearchReviewsEndpointMutationBody = BodyType<SearchReviewsCommand>
    export type SearchReviewsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Searches Reviews with pagination and filtering
 */
export const useSearchReviewsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchReviewsEndpoint>>, TError,{data: BodyType<SearchReviewsCommand>;version?: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchReviewsEndpoint>>,
        TError,
        {data: BodyType<SearchReviewsCommand>;version?: string},
        TContext
      > => {

      const mutationOptions = getSearchReviewsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve the details of a role by its ID.
 * @summary Get role details by ID
 */
export const getRoleByIdEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RoleDto>(
      {url: `/api/roles/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoleByIdEndpointQueryKey = (id: string,) => {
    return [`/api/roles/${id}`] as const;
    }

    
export const getGetRoleByIdEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleByIdEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleByIdEndpoint>>> = ({ signal }) => getRoleByIdEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleByIdEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleByIdEndpoint>>>
export type GetRoleByIdEndpointQueryError = ErrorType<unknown>


export function useGetRoleByIdEndpoint<TData = Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleByIdEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRoleByIdEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleByIdEndpoint<TData = Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleByIdEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRoleByIdEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleByIdEndpoint<TData = Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get role details by ID
 */

export function useGetRoleByIdEndpoint<TData = Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleByIdEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Remove a role from the system by its ID.
 * @summary Delete a role by ID
 */
export const deleteRoleEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/roles/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoleEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoleEndpoint>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteRoleEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoleEndpoint>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteRoleEndpoint(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoleEndpoint>>>
    
    export type DeleteRoleEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Delete a role by ID
 */
export const useDeleteRoleEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoleEndpoint>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a list of all roles available in the system.
 * @summary Get a list of all roles
 */
export const getRolesEndpoint = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RoleDto[]>(
      {url: `/api/roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRolesEndpointQueryKey = () => {
    return [`/api/roles`] as const;
    }

    
export const getGetRolesEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getRolesEndpoint>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesEndpoint>>> = ({ signal }) => getRolesEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRolesEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesEndpoint>>>
export type GetRolesEndpointQueryError = ErrorType<unknown>


export function useGetRolesEndpoint<TData = Awaited<ReturnType<typeof getRolesEndpoint>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRolesEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesEndpoint<TData = Awaited<ReturnType<typeof getRolesEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRolesEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesEndpoint<TData = Awaited<ReturnType<typeof getRolesEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a list of all roles
 */

export function useGetRolesEndpoint<TData = Awaited<ReturnType<typeof getRolesEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRolesEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new role or update an existing role.
 * @summary Create or update a role
 */
export const createOrUpdateRoleEndpoint = (
    createOrUpdateRoleCommand: BodyType<CreateOrUpdateRoleCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RoleDto>(
      {url: `/api/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrUpdateRoleCommand, signal
    },
      options);
    }
  


export const getCreateOrUpdateRoleEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>, TError,{data: BodyType<CreateOrUpdateRoleCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>, TError,{data: BodyType<CreateOrUpdateRoleCommand>}, TContext> => {

const mutationKey = ['createOrUpdateRoleEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>, {data: BodyType<CreateOrUpdateRoleCommand>}> = (props) => {
          const {data} = props ?? {};

          return  createOrUpdateRoleEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrUpdateRoleEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>>
    export type CreateOrUpdateRoleEndpointMutationBody = BodyType<CreateOrUpdateRoleCommand>
    export type CreateOrUpdateRoleEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Create or update a role
 */
export const useCreateOrUpdateRoleEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>, TError,{data: BodyType<CreateOrUpdateRoleCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrUpdateRoleEndpoint>>,
        TError,
        {data: BodyType<CreateOrUpdateRoleCommand>},
        TContext
      > => {

      const mutationOptions = getCreateOrUpdateRoleEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * get role permissions
 * @summary get role permissions
 */
export const getRolePermissionsEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RoleDto>(
      {url: `/api/roles/${id}/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRolePermissionsEndpointQueryKey = (id: string,) => {
    return [`/api/roles/${id}/permissions`] as const;
    }

    
export const getGetRolePermissionsEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolePermissionsEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>> = ({ signal }) => getRolePermissionsEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRolePermissionsEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>>
export type GetRolePermissionsEndpointQueryError = ErrorType<unknown>


export function useGetRolePermissionsEndpoint<TData = Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolePermissionsEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRolePermissionsEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolePermissionsEndpoint<TData = Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolePermissionsEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getRolePermissionsEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolePermissionsEndpoint<TData = Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get role permissions
 */

export function useGetRolePermissionsEndpoint<TData = Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolePermissionsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRolePermissionsEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * update role permissions
 * @summary update role permissions
 */
export const updateRolePermissionsEndpoint = (
    id: string,
    updatePermissionsCommand: BodyType<UpdatePermissionsCommand>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/roles/${id}/permissions`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updatePermissionsCommand
    },
      options);
    }
  


export const getUpdateRolePermissionsEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>, TError,{id: string;data: BodyType<UpdatePermissionsCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>, TError,{id: string;data: BodyType<UpdatePermissionsCommand>}, TContext> => {

const mutationKey = ['updateRolePermissionsEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>, {id: string;data: BodyType<UpdatePermissionsCommand>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRolePermissionsEndpoint(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRolePermissionsEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>>
    export type UpdateRolePermissionsEndpointMutationBody = BodyType<UpdatePermissionsCommand>
    export type UpdateRolePermissionsEndpointMutationError = ErrorType<unknown>

    /**
 * @summary update role permissions
 */
export const useUpdateRolePermissionsEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>, TError,{id: string;data: BodyType<UpdatePermissionsCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRolePermissionsEndpoint>>,
        TError,
        {id: string;data: BodyType<UpdatePermissionsCommand>},
        TContext
      > => {

      const mutationOptions = getUpdateRolePermissionsEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * creates a tenant
 * @summary creates a tenant
 */
export const createTenantEndpoint = (
    createTenantCommand: BodyType<CreateTenantCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateTenantResponse>(
      {url: `/api/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTenantCommand, signal
    },
      options);
    }
  


export const getCreateTenantEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenantEndpoint>>, TError,{data: BodyType<CreateTenantCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTenantEndpoint>>, TError,{data: BodyType<CreateTenantCommand>}, TContext> => {

const mutationKey = ['createTenantEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenantEndpoint>>, {data: BodyType<CreateTenantCommand>}> = (props) => {
          const {data} = props ?? {};

          return  createTenantEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof createTenantEndpoint>>>
    export type CreateTenantEndpointMutationBody = BodyType<CreateTenantCommand>
    export type CreateTenantEndpointMutationError = ErrorType<unknown>

    /**
 * @summary creates a tenant
 */
export const useCreateTenantEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenantEndpoint>>, TError,{data: BodyType<CreateTenantCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTenantEndpoint>>,
        TError,
        {data: BodyType<CreateTenantCommand>},
        TContext
      > => {

      const mutationOptions = getCreateTenantEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * get tenants
 * @summary get tenants
 */
export const getTenantsEndpoint = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDetail[]>(
      {url: `/api/tenants`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTenantsEndpointQueryKey = () => {
    return [`/api/tenants`] as const;
    }

    
export const getGetTenantsEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getTenantsEndpoint>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsEndpoint>>> = ({ signal }) => getTenantsEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantsEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsEndpoint>>>
export type GetTenantsEndpointQueryError = ErrorType<unknown>


export function useGetTenantsEndpoint<TData = Awaited<ReturnType<typeof getTenantsEndpoint>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getTenantsEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsEndpoint<TData = Awaited<ReturnType<typeof getTenantsEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getTenantsEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsEndpoint<TData = Awaited<ReturnType<typeof getTenantsEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get tenants
 */

export function useGetTenantsEndpoint<TData = Awaited<ReturnType<typeof getTenantsEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantsEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * get tenant by id
 * @summary get tenant by id
 */
export const getTenantByIdEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDetail>(
      {url: `/api/tenants/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTenantByIdEndpointQueryKey = (id: string,) => {
    return [`/api/tenants/${id}`] as const;
    }

    
export const getGetTenantByIdEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantByIdEndpoint>>> = ({ signal }) => getTenantByIdEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantByIdEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantByIdEndpoint>>>
export type GetTenantByIdEndpointQueryError = ErrorType<unknown>


export function useGetTenantByIdEndpoint<TData = Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantByIdEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getTenantByIdEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdEndpoint<TData = Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantByIdEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getTenantByIdEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdEndpoint<TData = Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get tenant by id
 */

export function useGetTenantByIdEndpoint<TData = Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantByIdEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantByIdEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * upgrade tenant subscription
 * @summary upgrade tenant subscription
 */
export const upgradeSubscriptionEndpoint = (
    upgradeSubscriptionCommand: BodyType<UpgradeSubscriptionCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UpgradeSubscriptionResponse>(
      {url: `/api/tenants/upgrade`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: upgradeSubscriptionCommand, signal
    },
      options);
    }
  


export const getUpgradeSubscriptionEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>, TError,{data: BodyType<UpgradeSubscriptionCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>, TError,{data: BodyType<UpgradeSubscriptionCommand>}, TContext> => {

const mutationKey = ['upgradeSubscriptionEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>, {data: BodyType<UpgradeSubscriptionCommand>}> = (props) => {
          const {data} = props ?? {};

          return  upgradeSubscriptionEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpgradeSubscriptionEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>>
    export type UpgradeSubscriptionEndpointMutationBody = BodyType<UpgradeSubscriptionCommand>
    export type UpgradeSubscriptionEndpointMutationError = ErrorType<unknown>

    /**
 * @summary upgrade tenant subscription
 */
export const useUpgradeSubscriptionEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>, TError,{data: BodyType<UpgradeSubscriptionCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof upgradeSubscriptionEndpoint>>,
        TError,
        {data: BodyType<UpgradeSubscriptionCommand>},
        TContext
      > => {

      const mutationOptions = getUpgradeSubscriptionEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * activate tenant
 * @summary activate tenant
 */
export const activateTenantEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ActivateTenantResponse>(
      {url: `/api/tenants/${id}/activate`, method: 'POST', signal
    },
      options);
    }
  


export const getActivateTenantEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateTenantEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof activateTenantEndpoint>>, TError,{id: string}, TContext> => {

const mutationKey = ['activateTenantEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activateTenantEndpoint>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  activateTenantEndpoint(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ActivateTenantEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof activateTenantEndpoint>>>
    
    export type ActivateTenantEndpointMutationError = ErrorType<unknown>

    /**
 * @summary activate tenant
 */
export const useActivateTenantEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateTenantEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof activateTenantEndpoint>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getActivateTenantEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * activate tenant
 * @summary activate tenant
 */
export const disableTenantEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DisableTenantResponse>(
      {url: `/api/tenants/${id}/deactivate`, method: 'POST', signal
    },
      options);
    }
  


export const getDisableTenantEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableTenantEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof disableTenantEndpoint>>, TError,{id: string}, TContext> => {

const mutationKey = ['disableTenantEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableTenantEndpoint>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  disableTenantEndpoint(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableTenantEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof disableTenantEndpoint>>>
    
    export type DisableTenantEndpointMutationError = ErrorType<unknown>

    /**
 * @summary activate tenant
 */
export const useDisableTenantEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableTenantEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableTenantEndpoint>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDisableTenantEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * refresh JWTs
 * @summary refresh JWTs
 */
export const refreshTokenEndpoint = (
    refreshTokenCommand: BodyType<RefreshTokenCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/api/token/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenCommand, signal
    },
      options);
    }
  


export const getRefreshTokenEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenEndpoint>>, TError,{data: BodyType<RefreshTokenCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshTokenEndpoint>>, TError,{data: BodyType<RefreshTokenCommand>}, TContext> => {

const mutationKey = ['refreshTokenEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshTokenEndpoint>>, {data: BodyType<RefreshTokenCommand>}> = (props) => {
          const {data} = props ?? {};

          return  refreshTokenEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof refreshTokenEndpoint>>>
    export type RefreshTokenEndpointMutationBody = BodyType<RefreshTokenCommand>
    export type RefreshTokenEndpointMutationError = ErrorType<unknown>

    /**
 * @summary refresh JWTs
 */
export const useRefreshTokenEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenEndpoint>>, TError,{data: BodyType<RefreshTokenCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshTokenEndpoint>>,
        TError,
        {data: BodyType<RefreshTokenCommand>},
        TContext
      > => {

      const mutationOptions = getRefreshTokenEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * generate JWTs
 * @summary generate JWTs
 */
export const tokenGenerationEndpoint = (
    tokenGenerationCommand: BodyType<TokenGenerationCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/api/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenGenerationCommand, signal
    },
      options);
    }
  


export const getTokenGenerationEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenGenerationEndpoint>>, TError,{data: BodyType<TokenGenerationCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokenGenerationEndpoint>>, TError,{data: BodyType<TokenGenerationCommand>}, TContext> => {

const mutationKey = ['tokenGenerationEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokenGenerationEndpoint>>, {data: BodyType<TokenGenerationCommand>}> = (props) => {
          const {data} = props ?? {};

          return  tokenGenerationEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokenGenerationEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof tokenGenerationEndpoint>>>
    export type TokenGenerationEndpointMutationBody = BodyType<TokenGenerationCommand>
    export type TokenGenerationEndpointMutationError = ErrorType<unknown>

    /**
 * @summary generate JWTs
 */
export const useTokenGenerationEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenGenerationEndpoint>>, TError,{data: BodyType<TokenGenerationCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokenGenerationEndpoint>>,
        TError,
        {data: BodyType<TokenGenerationCommand>},
        TContext
      > => {

      const mutationOptions = getTokenGenerationEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * register user
 * @summary register user
 */
export const registerUserEndpoint = (
    registerUserCommand: BodyType<RegisterUserCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RegisterUserResponse>(
      {url: `/api/users/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerUserCommand, signal
    },
      options);
    }
  


export const getRegisterUserEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext> => {

const mutationKey = ['registerUserEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUserEndpoint>>, {data: BodyType<RegisterUserCommand>}> = (props) => {
          const {data} = props ?? {};

          return  registerUserEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUserEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof registerUserEndpoint>>>
    export type RegisterUserEndpointMutationBody = BodyType<RegisterUserCommand>
    export type RegisterUserEndpointMutationError = ErrorType<unknown>

    /**
 * @summary register user
 */
export const useRegisterUserEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUserEndpoint>>,
        TError,
        {data: BodyType<RegisterUserCommand>},
        TContext
      > => {

      const mutationOptions = getRegisterUserEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * self register user
 * @summary self register user
 */
export const selfRegisterUserEndpoint = (
    registerUserCommand: BodyType<RegisterUserCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RegisterUserResponse>(
      {url: `/api/users/self-register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerUserCommand, signal
    },
      options);
    }
  


export const getSelfRegisterUserEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selfRegisterUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof selfRegisterUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext> => {

const mutationKey = ['selfRegisterUserEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof selfRegisterUserEndpoint>>, {data: BodyType<RegisterUserCommand>}> = (props) => {
          const {data} = props ?? {};

          return  selfRegisterUserEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SelfRegisterUserEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof selfRegisterUserEndpoint>>>
    export type SelfRegisterUserEndpointMutationBody = BodyType<RegisterUserCommand>
    export type SelfRegisterUserEndpointMutationError = ErrorType<unknown>

    /**
 * @summary self register user
 */
export const useSelfRegisterUserEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof selfRegisterUserEndpoint>>, TError,{data: BodyType<RegisterUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof selfRegisterUserEndpoint>>,
        TError,
        {data: BodyType<RegisterUserCommand>},
        TContext
      > => {

      const mutationOptions = getSelfRegisterUserEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * update user profile
 * @summary update user profile
 */
export const updateUserEndpoint = (
    updateUserCommand: BodyType<UpdateUserCommand>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/users/profile`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserCommand
    },
      options);
    }
  


export const getUpdateUserEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpoint>>, TError,{data: BodyType<UpdateUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpoint>>, TError,{data: BodyType<UpdateUserCommand>}, TContext> => {

const mutationKey = ['updateUserEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserEndpoint>>, {data: BodyType<UpdateUserCommand>}> = (props) => {
          const {data} = props ?? {};

          return  updateUserEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserEndpoint>>>
    export type UpdateUserEndpointMutationBody = BodyType<UpdateUserCommand>
    export type UpdateUserEndpointMutationError = ErrorType<unknown>

    /**
 * @summary update user profile
 */
export const useUpdateUserEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserEndpoint>>, TError,{data: BodyType<UpdateUserCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserEndpoint>>,
        TError,
        {data: BodyType<UpdateUserCommand>},
        TContext
      > => {

      const mutationOptions = getUpdateUserEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get current user information based on token
 * @summary Get current user information based on token
 */
export const getMeEndpoint = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDetail>(
      {url: `/api/users/profile`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMeEndpointQueryKey = () => {
    return [`/api/users/profile`] as const;
    }

    
export const getGetMeEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getMeEndpoint>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeEndpoint>>> = ({ signal }) => getMeEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMeEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getMeEndpoint>>>
export type GetMeEndpointQueryError = ErrorType<unknown>


export function useGetMeEndpoint<TData = Awaited<ReturnType<typeof getMeEndpoint>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMeEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getMeEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMeEndpoint<TData = Awaited<ReturnType<typeof getMeEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMeEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getMeEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMeEndpoint<TData = Awaited<ReturnType<typeof getMeEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current user information based on token
 */

export function useGetMeEndpoint<TData = Awaited<ReturnType<typeof getMeEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMeEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMeEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * get users list
 * @summary get users list
 */
export const getUsersListEndpoint = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDetail[]>(
      {url: `/api/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUsersListEndpointQueryKey = () => {
    return [`/api/users`] as const;
    }

    
export const getGetUsersListEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getUsersListEndpoint>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersListEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersListEndpoint>>> = ({ signal }) => getUsersListEndpoint(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUsersListEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersListEndpoint>>>
export type GetUsersListEndpointQueryError = ErrorType<unknown>


export function useGetUsersListEndpoint<TData = Awaited<ReturnType<typeof getUsersListEndpoint>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersListEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUsersListEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersListEndpoint<TData = Awaited<ReturnType<typeof getUsersListEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersListEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUsersListEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersListEndpoint<TData = Awaited<ReturnType<typeof getUsersListEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get users list
 */

export function useGetUsersListEndpoint<TData = Awaited<ReturnType<typeof getUsersListEndpoint>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersListEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUsersListEndpointQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * delete user profile
 * @summary delete user profile
 */
export const deleteUserEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUserEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserEndpoint>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUserEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserEndpoint>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserEndpoint(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserEndpoint>>>
    
    export type DeleteUserEndpointMutationError = ErrorType<unknown>

    /**
 * @summary delete user profile
 */
export const useDeleteUserEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserEndpoint>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserEndpoint>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get another user's profile details by user ID.
 * @summary Get user profile by ID
 */
export const getUserEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDetail>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserEndpointQueryKey = (id: string,) => {
    return [`/api/users/${id}`] as const;
    }

    
export const getGetUserEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getUserEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserEndpoint>>> = ({ signal }) => getUserEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getUserEndpoint>>>
export type GetUserEndpointQueryError = ErrorType<unknown>


export function useGetUserEndpoint<TData = Awaited<ReturnType<typeof getUserEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserEndpoint<TData = Awaited<ReturnType<typeof getUserEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserEndpoint<TData = Awaited<ReturnType<typeof getUserEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get user profile by ID
 */

export function useGetUserEndpoint<TData = Awaited<ReturnType<typeof getUserEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Generates a password reset token and sends it via email.
 * @summary Forgot password
 */
export const forgotPasswordEndpoint = (
    forgotPasswordCommand: BodyType<ForgotPasswordCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/users/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: forgotPasswordCommand, signal
    },
      options);
    }
  


export const getForgotPasswordEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPasswordEndpoint>>, TError,{data: BodyType<ForgotPasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof forgotPasswordEndpoint>>, TError,{data: BodyType<ForgotPasswordCommand>}, TContext> => {

const mutationKey = ['forgotPasswordEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPasswordEndpoint>>, {data: BodyType<ForgotPasswordCommand>}> = (props) => {
          const {data} = props ?? {};

          return  forgotPasswordEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ForgotPasswordEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPasswordEndpoint>>>
    export type ForgotPasswordEndpointMutationBody = BodyType<ForgotPasswordCommand>
    export type ForgotPasswordEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Forgot password
 */
export const useForgotPasswordEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forgotPasswordEndpoint>>, TError,{data: BodyType<ForgotPasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof forgotPasswordEndpoint>>,
        TError,
        {data: BodyType<ForgotPasswordCommand>},
        TContext
      > => {

      const mutationOptions = getForgotPasswordEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Change password
 * @summary Changes password
 */
export const changePasswordEndpoint = (
    changePasswordCommand: BodyType<ChangePasswordCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/users/change-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: changePasswordCommand, signal
    },
      options);
    }
  


export const getChangePasswordEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordEndpoint>>, TError,{data: BodyType<ChangePasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof changePasswordEndpoint>>, TError,{data: BodyType<ChangePasswordCommand>}, TContext> => {

const mutationKey = ['changePasswordEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePasswordEndpoint>>, {data: BodyType<ChangePasswordCommand>}> = (props) => {
          const {data} = props ?? {};

          return  changePasswordEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof changePasswordEndpoint>>>
    export type ChangePasswordEndpointMutationBody = BodyType<ChangePasswordCommand>
    export type ChangePasswordEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Changes password
 */
export const useChangePasswordEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordEndpoint>>, TError,{data: BodyType<ChangePasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changePasswordEndpoint>>,
        TError,
        {data: BodyType<ChangePasswordCommand>},
        TContext
      > => {

      const mutationOptions = getChangePasswordEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Resets the password using the token and new password provided.
 * @summary Reset password
 */
export const resetPasswordEndpoint = (
    resetPasswordCommand: BodyType<ResetPasswordCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/users/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: resetPasswordCommand, signal
    },
      options);
    }
  


export const getResetPasswordEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPasswordEndpoint>>, TError,{data: BodyType<ResetPasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetPasswordEndpoint>>, TError,{data: BodyType<ResetPasswordCommand>}, TContext> => {

const mutationKey = ['resetPasswordEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetPasswordEndpoint>>, {data: BodyType<ResetPasswordCommand>}> = (props) => {
          const {data} = props ?? {};

          return  resetPasswordEndpoint(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetPasswordEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof resetPasswordEndpoint>>>
    export type ResetPasswordEndpointMutationBody = BodyType<ResetPasswordCommand>
    export type ResetPasswordEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Reset password
 */
export const useResetPasswordEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPasswordEndpoint>>, TError,{data: BodyType<ResetPasswordCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetPasswordEndpoint>>,
        TError,
        {data: BodyType<ResetPasswordCommand>},
        TContext
      > => {

      const mutationOptions = getResetPasswordEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get current user permissions
 * @summary Get current user permissions
 */
export const getUserPermissions = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/api/users/permissions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserPermissionsQueryKey = () => {
    return [`/api/users/permissions`] as const;
    }

    
export const getGetUserPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof getUserPermissions>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPermissions>>> = ({ signal }) => getUserPermissions(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserPermissions>>>
export type GetUserPermissionsQueryError = ErrorType<unknown>


export function useGetUserPermissions<TData = Awaited<ReturnType<typeof getUserPermissions>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof getUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserPermissions<TData = Awaited<ReturnType<typeof getUserPermissions>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof getUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserPermissions<TData = Awaited<ReturnType<typeof getUserPermissions>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current user permissions
 */

export function useGetUserPermissions<TData = Awaited<ReturnType<typeof getUserPermissions>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserPermissionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Toggle a user's active status
 * @summary Toggle a user's active status
 */
export const toggleUserStatusEndpoint = (
    id: string,
    toggleUserStatusCommand: BodyType<ToggleUserStatusCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/users/${id}/toggle-status`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: toggleUserStatusCommand, signal
    },
      options);
    }
  


export const getToggleUserStatusEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleUserStatusEndpoint>>, TError,{id: string;data: BodyType<ToggleUserStatusCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof toggleUserStatusEndpoint>>, TError,{id: string;data: BodyType<ToggleUserStatusCommand>}, TContext> => {

const mutationKey = ['toggleUserStatusEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof toggleUserStatusEndpoint>>, {id: string;data: BodyType<ToggleUserStatusCommand>}> = (props) => {
          const {id,data} = props ?? {};

          return  toggleUserStatusEndpoint(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ToggleUserStatusEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof toggleUserStatusEndpoint>>>
    export type ToggleUserStatusEndpointMutationBody = BodyType<ToggleUserStatusCommand>
    export type ToggleUserStatusEndpointMutationError = ErrorType<unknown>

    /**
 * @summary Toggle a user's active status
 */
export const useToggleUserStatusEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof toggleUserStatusEndpoint>>, TError,{id: string;data: BodyType<ToggleUserStatusCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof toggleUserStatusEndpoint>>,
        TError,
        {id: string;data: BodyType<ToggleUserStatusCommand>},
        TContext
      > => {

      const mutationOptions = getToggleUserStatusEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * assign roles
 * @summary assign roles
 */
export const assignRolesToUserEndpoint = (
    id: string,
    assignUserRoleCommand: BodyType<AssignUserRoleCommand>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/users/${id}/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignUserRoleCommand, signal
    },
      options);
    }
  


export const getAssignRolesToUserEndpointMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRolesToUserEndpoint>>, TError,{id: string;data: BodyType<AssignUserRoleCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof assignRolesToUserEndpoint>>, TError,{id: string;data: BodyType<AssignUserRoleCommand>}, TContext> => {

const mutationKey = ['assignRolesToUserEndpoint'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignRolesToUserEndpoint>>, {id: string;data: BodyType<AssignUserRoleCommand>}> = (props) => {
          const {id,data} = props ?? {};

          return  assignRolesToUserEndpoint(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignRolesToUserEndpointMutationResult = NonNullable<Awaited<ReturnType<typeof assignRolesToUserEndpoint>>>
    export type AssignRolesToUserEndpointMutationBody = BodyType<AssignUserRoleCommand>
    export type AssignRolesToUserEndpointMutationError = ErrorType<unknown>

    /**
 * @summary assign roles
 */
export const useAssignRolesToUserEndpoint = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRolesToUserEndpoint>>, TError,{id: string;data: BodyType<AssignUserRoleCommand>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof assignRolesToUserEndpoint>>,
        TError,
        {id: string;data: BodyType<AssignUserRoleCommand>},
        TContext
      > => {

      const mutationOptions = getAssignRolesToUserEndpointMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * get user roles
 * @summary get user roles
 */
export const getUserRolesEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRoleDetail[]>(
      {url: `/api/users/${id}/roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserRolesEndpointQueryKey = (id: string,) => {
    return [`/api/users/${id}/roles`] as const;
    }

    
export const getGetUserRolesEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserRolesEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRolesEndpoint>>> = ({ signal }) => getUserRolesEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserRolesEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRolesEndpoint>>>
export type GetUserRolesEndpointQueryError = ErrorType<unknown>


export function useGetUserRolesEndpoint<TData = Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserRolesEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserRolesEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserRolesEndpoint<TData = Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserRolesEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserRolesEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserRolesEndpoint<TData = Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary get user roles
 */

export function useGetUserRolesEndpoint<TData = Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRolesEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserRolesEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user's audit trail details.
 * @summary Get user's audit trail details
 */
export const getUserAuditTrailEndpoint = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuditTrail[]>(
      {url: `/api/users/${id}/audit-trails`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserAuditTrailEndpointQueryKey = (id: string,) => {
    return [`/api/users/${id}/audit-trails`] as const;
    }

    
export const getGetUserAuditTrailEndpointQueryOptions = <TData = Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserAuditTrailEndpointQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>> = ({ signal }) => getUserAuditTrailEndpoint(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserAuditTrailEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>>
export type GetUserAuditTrailEndpointQueryError = ErrorType<unknown>


export function useGetUserAuditTrailEndpoint<TData = Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserAuditTrailEndpoint<TData = Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>,
          TError,
          Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserAuditTrailEndpoint<TData = Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get user's audit trail details
 */

export function useGetUserAuditTrailEndpoint<TData = Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAuditTrailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserAuditTrailEndpointQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * confirm user email
 * @summary confirm user email
 */
export const confirmEmailEndpoint = (
    params: ConfirmEmailEndpointParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/api/users/confirm-email`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getConfirmEmailEndpointQueryKey = (params: ConfirmEmailEndpointParams,) => {
    return [`/api/users/confirm-email`, ...(params ? [params]: [])] as const;
    }

    
export const getConfirmEmailEndpointQueryOptions = <TData = Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError = ErrorType<unknown>>(params: ConfirmEmailEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getConfirmEmailEndpointQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof confirmEmailEndpoint>>> = ({ signal }) => confirmEmailEndpoint(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ConfirmEmailEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof confirmEmailEndpoint>>>
export type ConfirmEmailEndpointQueryError = ErrorType<unknown>


export function useConfirmEmailEndpoint<TData = Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError = ErrorType<unknown>>(
 params: ConfirmEmailEndpointParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof confirmEmailEndpoint>>,
          TError,
          Awaited<ReturnType<typeof confirmEmailEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfirmEmailEndpoint<TData = Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError = ErrorType<unknown>>(
 params: ConfirmEmailEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof confirmEmailEndpoint>>,
          TError,
          Awaited<ReturnType<typeof confirmEmailEndpoint>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useConfirmEmailEndpoint<TData = Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError = ErrorType<unknown>>(
 params: ConfirmEmailEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary confirm user email
 */

export function useConfirmEmailEndpoint<TData = Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError = ErrorType<unknown>>(
 params: ConfirmEmailEndpointParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof confirmEmailEndpoint>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getConfirmEmailEndpointQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
